<!doctype html> 
<html> 

<head> 
<meta charset="utf-8" /> 
<meta name="apple-mobile-web-app-capable" content="yes"> 
<meta name="apple-mobile-web-app-status-bar-style" content="black"> 
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height"> 
<link rel="manifest" href="manifest.json"> 
<link rel="apple-touch-icon" href="icon.png"> 
<link rel="preload" href="audio-worklet.js" as="script"> 
<link href="dark.css" rel="stylesheet"> 
<title>DS Emulator</title> 
</head> 

<body> 
<style> 
html, 
body { 
overflow-y: hidden; 
overflow-x: hidden; 
-webkit-user-select: none; 
user-select: none; 
-webkit-touch-callout: none; 
cursor: inherit; 
} 

body { 
background-color: black; 
color: white; 
padding: 0; 
margin: 0; 
width: 100%; 
height: 100%; 
font-family: 'Myriad Set Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif; 


} 

canvas { 
position: absolute; 
z-index: 1; 
image-rendering: pixelated; 
} 

#msg-layer { 
position: absolute; 
left: 0; 
width: 100%; 
top: 40vh; 
background: rgba(0, 0, 0, 0.5); 
z-index: 3; 
} 

#vk-layer { 
position: absolute; 
left: 0; 
top: 0; 
width: 100%; 
height: 100%; 
z-index: 2; 
touch-action: none; 
} 

#menu { 
position: absolute; 
left: 0; 
top: 0; 
width: 100%; 
height: 100%; 
z-index: 4; 
overflow: hidden scroll; 
background: rgba(0, 127, 255, 0.5); 
} 

#menu button { 
background: transparent; 
} 
#menu button:active { 
background: rgba(255, 255, 255, 0.5); 
} 

a, 
a:visited { 
color: white; 

} 

.vk-round { 
text-align: center; 
vertical-align: middle; 
border-radius: 50%; 
display: inline-block; 
} 


.vk { 
color: rgba(0, 0, 0, 0.2); 
background-color: rgba(255, 255, 255, 0.25); 
position: absolute; 
z-index: 1; 
text-align: center; 
vertical-align: middle; 
display: inline-block; 
} 


.vk-touched { 
background-color: rgba(255, 255, 255, 0.75) !important 
} 
</style>
  <div id="pause-menu" class="menu" style="background: rgba(32,43,56,0.7);" hidden>
        <h1><button onclick="setPauseMenu(false)"> ‚Üê Back </button>Game Paused</h1>
        <hr>
        Memory Hacking:<br>
        <input id="cht-addr" value="0x">
        <input id="cht-value">
        <button onclick="chtReadBtn()">Read</button>
        <button onclick="chtWriteBtn()">Write</button>
        <hr>
        Savegame management:<br>
        <button onclick="savBackupBtn()">Backup</button>
        <input type="file" id="sav-file" />
        <button onclick="savRestoreBtn()">Restore</button>
    </div>
    <div id="welcome" class="menu">
        
        <div id="wasm-loading">
            Loading WebAssembly, please wait...
        </div>
        <div id="select-rom" hidden>
<input type="file" id="romFile" onchange="onFileSelected()" hidden /></p>
<button onclick="$id('romFile').click()" style="width:calc(100% - 2em);margin: 1em;">Choose File...</button>

        </div>
        <hr>
        Ver. 20220318
        <p>
            This software should not be used to play games you have not legally obtained.
        </p>
        <div id="ios-hint" hidden>
            Due to limitations of iOS, please <b>add this page to the home screen</b> and launch it from the home screen icon to enable features including savegame and full screen.
            <p style="text-align: center;">üëá</p>
        </div>
    </div>
    <div id="msg-layer" hidden>
        <p id="msg-text"></p>
    </div>
    <div id="vk-layer" hidden>
        <div class="vk-rect vk" data-k="menu">Menu</div>
        <div class="vk-rect vk" data-k="turbo">Turbo</div>
        <div class="vk-rect vk" data-k="l">L</div>
        <div class="vk-rect vk" data-k="r">R</div>
        <div class="vk-round vk" data-k="a">A</div>
        <div class="vk-round vk" data-k="b">B</div>
        <div class="vk-rect vk" data-k="select">Select</div>
        <div class="vk-rect vk" data-k="start">Start</div>
        <div class=" vk" data-k="left">‚Üê</div>
        <div class=" vk" data-k="right">‚Üí</div>
        <div class=" vk" data-k="up">‚Üë</div>
        <div class=" vk" data-k="down">‚Üì</div>
        <div class=" vk vk-hide" style="background-color: transparent !important" data-k="ul"></div>
        <div class=" vk vk-hide" style="background-color: transparent !important" data-k="ur"></div>
        <div class=" vk vk-hide" style="background-color: transparent !important" data-k="dl"></div>
        <div class=" vk vk-hide" style="background-color: transparent !important" data-k="dr"></div>
    </div>
    <canvas width="240" height="160" id="gba-canvas" style="touch-action: none;image-rendering: pixelated;"></canvas>
    <script src="localforage.js"></script>
    <script>
        function $id(id) {
            return document.getElementById(id);
        }
        if (!window.WebAssembly) {
            alert('Sorry, your browser does not support WebAssembly. :(')
        } 

        window.onerror = function (msg, url, line, col, error) {
            var extra = !col ? '' : '\ncolumn: ' + col;
            extra += !error ? '' : '\nerror: ' + error;
            alert("Error: " + msg + "\nurl: " + url + "\nline: " + line + extra);
            window.onerror = console.log
            debugger
            return true;
        };

        var isIOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
        var isWebApp = navigator.standalone || false
        var isSaveSupported = true
        if (isIOS) {
            //document.getElementById('romFile').files = null;
            if (!isWebApp) {
                // On iOS Safari, the indexedDB will be cleared after 7 days. 
                // To prevent users from frustration, we don't allow savegaming on iOS unless the we are in the PWA mode.
                isSaveSupported = false
                alert('Due to limitations of iOS, please add this page to the home screen and launch it from the home screen icon to enable features including savegame and full screen.')
                var divIosHint = document.getElementById('ios-hint')
                divIosHint.hidden = false
                divIosHint.style = 'position: absolute; bottom: '+ divIosHint.clientHeight  + 'px;'
            }
        }


        var keyState = {
        };
        const keyList = ["a", "b", "select", "start", "right", "left", 'up', 'down', 'r', 'l'];

        const AUDIO_BLOCK_SIZE = 1024
        const AUDIO_FIFO_MAXLEN = 4900
        var audioContext
        var scriptProcessor
        var audioFifo0 = new Int16Array(AUDIO_FIFO_MAXLEN)
        var audioFifo1 = new Int16Array(AUDIO_FIFO_MAXLEN)
        var audioFifoHead = 0
        var audioFifoCnt = 0

        var fileInput = document.getElementById('romFile')
        var canvas = document.getElementById('gba-canvas')
        var drawContext = canvas.getContext('2d')
        var romBuffer = -1
        var idata
        var isRunning = false
        var isWasmReady = false
        var wasmAudioBuf
        var wasmSaveBuf
        const wasmSaveBufLen = 0x20000 + 0x2000
        var tmpSaveBuf = new Uint8Array(wasmSaveBufLen)

        var frameCnt = 0
        var last128FrameTime = 0
        var lastFrameTime = 0
        var frameSkip = 0
        var lowLatencyMode = false

        var lastCheckedSaveState = 0

        var gameID
        var romFileName

        var turboMode = false
        var turboInterval = -1

        var gbaWidth
        var gbaHeight




        function processAudio(event) {
            var outputBuffer = event.outputBuffer
            var audioData0 = outputBuffer.getChannelData(0)
            var audioData1 = outputBuffer.getChannelData(1)

            if ((!isRunning) || (turboMode)) {
                for (var i = 0; i < AUDIO_BLOCK_SIZE; i++) {
                    audioData0[i] = 0
                    audioData1[i] = 0
                }
                return
            }
            while (audioFifoCnt < AUDIO_BLOCK_SIZE) {
                //console.log('audio fifo underflow, running a new frame')
                emuRunFrame();
            }

            var copySize = AUDIO_BLOCK_SIZE
            if (audioFifoCnt < copySize) {
                copySize = audioFifoCnt
            }
            for (var i = 0; i < copySize; i++) {
                audioData0[i] = audioFifo0[audioFifoHead] / 32768.0
                audioData1[i] = audioFifo1[audioFifoHead] / 32768.0
                audioFifoHead = (audioFifoHead + 1) % AUDIO_FIFO_MAXLEN
                audioFifoCnt--
            }
        }

        // must be called in user gesture
        function tryInitSound() {
            if (audioContext) {
                if (audioContext.state != 'running') {
                    audioContext.resume()
                }
                return;
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 0.0001, sampleRate: 48000 });
                scriptProcessor = audioContext.createScriptProcessor(AUDIO_BLOCK_SIZE, 0, 2)
                scriptProcessor.onaudioprocess = processAudio
                scriptProcessor.connect(audioContext.destination)

                audioContext.resume()
            } catch (e) {
                console.log(e)
                //alert('Cannnot init sound ')
            }
        }



        function writeAudio(ptr, frames) {
            //console.log(ptr, frames)
            if (turboMode) {
                return
            }
            if (!wasmAudioBuf) {
                wasmAudioBuf = new Int16Array(Module.HEAPU8.buffer).subarray(ptr / 2, ptr / 2 + 2048)
            }
            var tail = (audioFifoHead + audioFifoCnt) % AUDIO_FIFO_MAXLEN
            if (audioFifoCnt + frames >= AUDIO_FIFO_MAXLEN) {
                console.log('audio fifo overflow (wow)', audioFifoCnt)
                return
            }
            for (var i = 0; i < frames; i++) {
                audioFifo0[tail] = wasmAudioBuf[i * 2]
                audioFifo1[tail] = wasmAudioBuf[i * 2 + 1]
                tail = (tail + 1) % AUDIO_FIFO_MAXLEN
            }
            audioFifoCnt += frames
        }

        function drawFrame(ptr) {
            //console.log(ptr)
            if (!idata) {
                // assuming ptr is always same
                idata = new ImageData(new Uint8ClampedArray(Module.HEAPU8.buffer).subarray(ptr, ptr + 240 * 160 * 4), 240, 160)
            }
            drawContext.putImageData(idata, 0, 0)
        }

        function wasmReady() {
            romBuffer = Module._getBuffer(1)
            var ptr = Module._getBuffer(0)
            wasmSaveBuf = Module.HEAPU8.subarray(ptr, ptr + wasmSaveBufLen)
            isWasmReady = true
            document.getElementById('wasm-loading').hidden = true
            document.getElementById('select-rom').hidden = false

        }

        function loadSaveGame(index, cb) {
            console.log('load', gameID, index)
            localforage.getItem('gba-' + gameID + '-save-' + index, function (err, data) {
                //console.log(err, data)
                if (data) {
                    wasmSaveBuf.set(data)
                    clearSaveBufState()
                    cb(true)
                } else {
                    clearSaveBufState()
                    cb(false)
                }
            })
        }

        function saveSaveGame(index, cb) {
            console.log('save', gameID, index)
            tmpSaveBuf.set(wasmSaveBuf)
            localforage.setItem('gba-' + gameID + '-save-' + index, tmpSaveBuf, function (err, data) {
                cb(true)
            })
        }

        function savBackupBtn() {
            var blob = new Blob([wasmSaveBuf], { type: "application/binary" });
            var link = document.createElement("a");
            link.href = window.URL.createObjectURL(blob);
            link.download = 'save-' + gameID + '.44gbasav';
            link.click();
        }

        function savRestoreBtn() {
            var file = document.getElementById('sav-file').files[0]
            if (file) {
                var fileReader = new FileReader()
                fileReader.onload = function (event) {
                    var arrayBuffer = event.target.result
                    var u8 = new Uint8Array(arrayBuffer)
                    wasmSaveBuf.set(u8)
                    alert('sav file loaded')
                    Module._resetCpu()
                    clearSaveBufState()
                };
                fileReader.readAsArrayBuffer(file)
            }
        }

        function loadRomArrayBuffer(arrayBuffer) {
            isRunning = false
            console.log(arrayBuffer)
            var u8 = new Uint8Array(arrayBuffer)
            gameID = ""
            if (u8[0xB2] != 0x96) {
                alert('Not a valid GBA ROM!')
                return
            }
            for (var i = 0xAC; i < 0xB2; i++) {
                console.log(u8[i])
                gameID += String.fromCharCode(u8[i])
            }
            if ((u8[0xAC] == 0) || (gameID.substr(0, 4) == '0000')) {
                // a homebrew! use file name as id
                gameID = romFileName
            }
            console.log('gameID', gameID)
            Module.HEAPU8.set(u8, romBuffer)
            var ret = Module._loadRom(u8.length)
            document.getElementById('welcome').hidden = true
            loadSaveGame(0, function () {
                Module._resetCpu()
                isRunning = true
            })

        }

        function onHomebrewListSelected() {
            if (!isWasmReady) {
                alert('WASM not ready!')
                return
            }
            tryInitSound()
            var fn = document.getElementById('homebrew-list').value
            if (fn == '') {
                return
            }
            romFileName = fn
            document.getElementById('select-rom').innerText = 'Downloading...'
            fetch('roms/' + fn + '.gba').then(function (resp) {
                resp.arrayBuffer().then(function (ab) {
                    loadRomArrayBuffer(ab)
                })
            });
        }

        function onFileSelected() {
            if (!isWasmReady) {
                alert('WASM not ready!')
                return
            }
            tryInitSound()
            var file = fileInput.files[0]
            var fileNameLower = file.name.toLowerCase()
            if (!fileNameLower.endsWith('.gba')) {
                alert('Please select a .gba file.')
                return
            }
            if (file) {
                romFileName = file.name
                var arrayBuffer
                var fileReader = new FileReader()
                fileReader.onload = function (event) {
                    var arrayBuffer = event.target.result
                    loadRomArrayBuffer(arrayBuffer)
                };
                fileReader.readAsArrayBuffer(file)
            }

        }


        function emuRunFrame() {
            processGamepadInput()
            if (isRunning) {
                frameCnt++
                if (frameCnt % 60 == 0) {
                    checkSaveBufState()
                }
                if (frameCnt % 128 == 0) {
                    
                    if (last128FrameTime) {
                        var diff = performance.now() - last128FrameTime
                        var frameInMs = diff / 128
                        var fps = -1
                        if (frameInMs > 0.001) {
                            fps = 1000 / frameInMs
                        }
                        console.log('fps', fps)
                    }
                    last128FrameTime = performance.now()

                }
                lastFrameTime = performance.now()
                Module._runFrame(getVKState());
            }
        }

        
        function emuLoop() {
            window.requestAnimationFrame(emuLoop)
            emuRunFrame()
        }
        emuLoop()



        function initVK() {
            var vks = document.getElementsByClassName('vk')
            for (var i = 0; i < vks.length; i++) {
                var vk = vks[i]
                var k = vks[i].getAttribute('data-k')
                keyState[k] = [vk, 0, 0]
            }
        }
        initVK()

        function makeVKStyle(top, left, w, h, fontSize) {
            return 'top:' + top + 'px;left:' + left + 'px;width:' + w + 'px;height:' + h + 'px;' + 'font-size:' + fontSize + 'px;line-height:' + h + 'px;'
        }


        function adjustVKLayout() {
            var isLandscape = window.innerWidth > window.innerHeight
            var baseSize = Math.min(Math.min(window.innerWidth, window.innerHeight) * 0.14, 50)
            var fontSize = baseSize * 0.7
            var offTop = 0
            var offLeft = 0

            if (!isLandscape) {
                offTop = gbaHeight + baseSize
                if ((offTop + baseSize * 7) > window.innerHeight) {
                    offTop = 0
                }
            } 

            var vkw = baseSize * 3
            var vkh = baseSize 
            
            keyState['l'][0].style = makeVKStyle(offTop + baseSize * 1.5, 0, vkw, vkh, fontSize)
            keyState['r'][0].style = makeVKStyle(offTop + baseSize * 1.5, window.innerWidth - vkw, vkw, vkh, fontSize)

            vkh = baseSize * 0.5
            keyState['turbo'][0].style = makeVKStyle(offTop + baseSize * 0.5, 0, vkw, vkh, fontSize)
            keyState['menu'][0].style = makeVKStyle(offTop + baseSize * 0.5, window.innerWidth - vkw, vkw, vkh, fontSize)

            vkh = baseSize
            vkw = baseSize
            offTop += baseSize * 3
            /*
            offLeft = isLandscape ? (baseSize * 1) : 0
            if (baseSize * 6 > window.innerWidth) {
                offLeft = 0
            }*/
            offLeft = 0
            
            keyState['up'][0].style = makeVKStyle(offTop, offLeft + vkw, vkw, vkh, fontSize)
            keyState['ul'][0].style = makeVKStyle(offTop, offLeft, vkw, vkh, fontSize)
            keyState['ur'][0].style = makeVKStyle(offTop, offLeft + vkw * 2, vkw, vkh, fontSize)
            keyState['down'][0].style = makeVKStyle(offTop + vkh * 2, offLeft + vkw, vkw, vkh, fontSize)
            keyState['dl'][0].style = makeVKStyle(offTop + vkh * 2, offLeft, vkw, vkh, fontSize)
            keyState['dr'][0].style = makeVKStyle(offTop + vkh * 2, offLeft + vkw * 2, vkw, vkh, fontSize)
            keyState['left'][0].style = makeVKStyle(offTop + vkh, offLeft + 0, vkw, vkh, fontSize)
            keyState['right'][0].style = makeVKStyle(offTop + vkh, offLeft + vkw * 2, vkw, vkh, fontSize)
            abSize = vkw * 1.3
            keyState['a'][0].style = makeVKStyle(offTop + vkh - baseSize * 0.5, window.innerWidth - abSize, abSize, abSize, fontSize)
            keyState['b'][0].style = makeVKStyle(offTop + vkh, window.innerWidth - abSize * 2.4, abSize, abSize, fontSize)

            vkh = baseSize * 0.5
            vkw = baseSize * 3

            offLeft = (window.innerWidth - vkw * 2.2) / 2
            offTop += baseSize * 3 + baseSize * 0.5
            if (isLandscape) {
                offTop = window.innerHeight - vkh
            }

            keyState['select'][0].style = makeVKStyle(offTop, offLeft , vkw, vkh, fontSize)
            keyState['start'][0].style = makeVKStyle(offTop, offLeft + vkw * 1.2 , vkw, vkh, fontSize)

            
        }

        function adjustSize() {
            var gbaMaxWidth = window.innerWidth
            var gbaMaxHeight = window.innerHeight - 20
            var l = 0
            var w = gbaMaxWidth
            var h = w / 240 * 160
            if (h > gbaMaxHeight) {
                h = gbaMaxHeight
                w = h / 160 * 240
            }
            var scaleFator = (w / 240) // | 0
            gbaWidth = 240 * scaleFator
            gbaHeight = 160 * scaleFator
            l += (window.innerWidth - gbaWidth) / 2;
            canvas.style = 'width:' + gbaWidth + 'px;height:' + gbaHeight + 'px;left:' + l + 'px;'
            adjustVKLayout()
        }

        window.onresize = adjustSize
        window.onorientationchange = adjustSize
        adjustSize()


        function handleTouch(event) {
            tryInitSound()
            if (!isRunning) {
                return
            }
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('vk-layer').hidden = false
            for (var k in keyState) {
                keyState[k][2] = 0
            }
            for (var i = 0; i < event.touches.length; i++) {
                var t = event.touches[i];
                var dom = document.elementFromPoint(t.clientX, t.clientY)
                if (dom) {
                    var k = dom.getAttribute('data-k')
                    if (k) {
                        keyState[k][2] = 1
                        if (k == 'ul') {
                            keyState['up'][2] = 1
                            keyState['left'][2] = 1
                        } else if (k == 'ur') {
                            keyState['up'][2] = 1
                            keyState['right'][2] = 1
                        } else if (k == 'dl') {
                            keyState['down'][2] = 1
                            keyState['left'][2] = 1
                        } else if (k == 'dr') {
                            keyState['down'][2] = 1
                            keyState['right'][2] = 1
                        }
                    }
                }
            }
            if (keyState['menu'][2]) {
                setPauseMenu(true)
            }
            if (keyState['turbo'][2] != keyState['turbo'][1]) {
                setTurboMode(keyState['turbo'][2])
            }
            for (var k in keyState) {
                if (keyState[k][1] != keyState[k][2]) {
                    var dom = keyState[k][0]
                    keyState[k][1] = keyState[k][2]
                    if (keyState[k][1]) {
                        dom.classList.add('vk-touched')
                    } else {
                        dom.classList.remove('vk-touched')
                    }

                }
            }
        }

        
        var currentConnectedGamepad = -1
        var gamePadKeyMap = {
            a: 1,
            b: 0,
            //x: 3,
            //y: 2,
            l: 4,
            r: 5,
            'select': 8,
            'start': 9,
            'up': 12,
            'down': 13,
            'left': 14,
            'right': 15
        }

        window.addEventListener("gamepadconnected", function (e) {
            console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                e.gamepad.index, e.gamepad.id,
                e.gamepad.buttons.length, e.gamepad.axes.length);
            showMsg('Gamepad connected.')
            currentConnectedGamepad = e.gamepad.index
        });

        function processGamepadInput() {
            if (currentConnectedGamepad < 0) {
                return
            }
            var gamepad = navigator.getGamepads()[currentConnectedGamepad]
            if (!gamepad) {
                showMsg('Gamepad disconnected.')
                currentConnectedGamepad = -1
                return
            }
            for (var k in keyState) {
                keyState[k][1] = 0
            }
            for (var k in gamePadKeyMap) {
                var btn = gamePadKeyMap[k]
                if (gamepad.buttons[btn].pressed) {
                    keyState[k][1] = 1
                }
            }
            // Axes
            if (gamepad.axes[0] < -0.5) {
                keyState['left'][1] = 1
            } else if (gamepad.axes[0] > 0.5) {
                keyState['right'][1] = 1
            }
            if (gamepad.axes[1] < -0.5) {
                keyState['up'][1] = 1
            } else if (gamepad.axes[1] > 0.5) {
                keyState['down'][1] = 1
            }
        }


        /*
                // dunno why, but we should do that first on iOS
                window.ontouchstart = function() {
        
                };
                window.ontouchstart = handleTouch;
                window.ontouchmove = handleTouch;
                window.ontouchcancel = handleTouch;
                window.ontouchend = handleTouch;*/
 
                //'touchcancel', , 'touchforcechange'
        ['touchstart', 'touchmove',  'touchend', 'touchcancel', 'touchenter', 'touchleave'].forEach((val) => {
            window.addEventListener(val, handleTouch)
        })

        document.getElementById('vk-layer').ontouchstart = (e) => {
            e.preventDefault()
        }



        function getVKState() {
            var ret = 0;
            for (var i = 0; i < 10; i++) {
                ret = ret | (keyState[keyList[i]][1] << i);
            }
            return ret;
        }

        function convertKeyCode(keyCode) {
            const keymap = [90, 88, 8, 13, 39, 37, 38, 40, 17, 16]
            //8bitdo Zero2 in Keyboard Mode
            const keymap2 = [71, 74, 78, 79, 70, 69, 67, 68, 77, 75]
            for (var i = 0; i < 10; i++) {
                if (keyCode == keymap[i]) {
                    return i
                }
                if (keyCode == keymap2[i]) {
                    return i
                }
            }
            return -1
        }

        document.onkeydown = function (e) {
            tryInitSound()
            console.log(e.keyCode)
            if (!isRunning) {
                return
            }
            e.preventDefault()

            var k = convertKeyCode(e.keyCode)
            if (k >= 0) {
                keyState[keyList[k]][1] = 1
            }
        }

        document.onkeyup = function (e) {
            if (!isRunning) {
                return
            }
            e.preventDefault()
            var k = convertKeyCode(e.keyCode)
            if (k >= 0) {
                keyState[keyList[k]][1] = 0
            }
            if (e.keyCode == 27) {
                setPauseMenu(true)
            }
        }

        function checkSaveBufState() {
            if (!isRunning) {
                return;
            }
            var state = Module._updateSaveBufState()
            //console.log(state)
            if ((lastCheckedSaveState == 1) && (state == 0) && (isSaveSupported))  {
                showMsg('Auto saving, please wait...')
                saveSaveGame(0, function () {
                    console.log('save done')
                })
            }
            lastCheckedSaveState = state
        }

        function clearSaveBufState() {
            lastCheckedSaveState = 0
            Module._updateSaveBufState()
        }


        function showMsg(msg) {
            document.getElementById('msg-text').innerText = msg
            document.getElementById('msg-layer').hidden = false
            setTimeout(function () {
                document.getElementById('msg-layer').hidden = true
            }, 1000)
        }

        function setTurboMode(t) {
            t = t ? true : false
            if (turboMode == t) {
                return
            }
            if (t) {
                turboInterval = setInterval(emuRunFrame, 2)
            } else {
                clearInterval(turboInterval)
            }
            turboMode = t
        }

        function setPauseMenu(t) {
            t = t ? true : false
            isRunning = !t
            document.getElementById('pause-menu').hidden = !t
        }

        localforage.ready().then(function () { }).catch(function (err) {
            alert('Save storage not supported: ' + err);
        })

        function chtWriteBtn() {
            var addr = parseInt(document.getElementById('cht-addr').value)
            if (!addr) {
                alert('Invalid addr'); return
            }
            Module._writeU32(addr,
                parseInt(document.getElementById('cht-value').value))


        }

        function chtReadBtn() {
            var addr = parseInt(document.getElementById('cht-addr').value)
            if (!addr) {
                alert('Invalid addr'); return
            }
            var val = Module._readU32(addr) >>> 0
            document.getElementById('cht-value').value = '0x' + val.toString(16)
        }

        window.addEventListener("gamepadconnected", function (e) {
            console.log("Gamepad connected")
        });

    </script>


    <script src="a.out.js"></script>
<div id="welcome" class="menu"> 

<div id="loading">Ë™≠„ÅøËæº„Åø‰∏≠</div> 
<div id="loadrom" hidden> 
<input id="rom" type="file" hidden> 
<button style="width:calc(100% - 2em);margin: 1em;" onclick="$id('rom').click()">„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû</button> 
</div> 
<hr> 
<p><a href="#" onclick="uiSwitchTo('menu')">‚öô Ë®≠ÂÆö</a></p> 
<div id="ios-hint" hidden> 
Due to iOS Safari limitations, you may need to add this page to your home screen before you can save the 
game. 
<p style="text-align: center;">‚¨á</p> 
</div> 

</div> 
<div id="vk-layer" hidden> 
<div class="vk-rect vk" data-k="menu" id="vk-menu">Menu</div> 
<div class="vk-rect vk" data-k="l">L</div> 
<div class="vk-rect vk" data-k="r">R</div> 
<div class="vk-round vk" data-k="a">A</div> 
<div class="vk-round vk" data-k="b">B</div> 
<div class="vk-round vk" data-k="x">X</div> 
<div class="vk-round vk" data-k="y">Y</div> 
<div class="vk-rect vk" data-k="select">-</div> 
<div class="vk-rect vk" data-k="start">+</div> 
<div class="vk-round vk" data-k="stick" id="vk-stick"></div> 
</div> 
<div style="z-index: 2;position: absolute;bottom: 20px;" id="fps"></div> 
<div id="msg-layer" hidden> 
<p id="msg-text"></p> 
</div> 
<div id="menu" hidden> 
<button onclick="uiMenuBack()">‚ùÆ Back</button> 
<hr> 
<input type="checkbox" id="power-save"> 
<label for="power-save">ÁúÅÈõªÂäõ„É¢„Éº„Éâ</label><br> 
<input type="checkbox" id="vk-enabled"> 
<label for="vk-enabled">‰ªÆÊÉ≥„Ç≠„Éº„Éú„Éº„Éâ</label><br> 
<hr> 
<div id="menu-savegame" hidden> 
<input type="file" id="restore-file" onchange="uiSaveRestore()" hidden> 
„Çª„Éº„Éñ„Éá„Éº„Çø: <button onclick="uiSaveBackup()">‚Üì „Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>|<button onclick="$id('restore-file').click()">‚Üë „Ç§„É≥„Éù„Éº„Éà</button> 
<hr> 
</div> 
</div> 
<div id="player" hidden> 
<canvas id="top" width="256" height="192"></canvas> 
<canvas id="bottom" width="256" height="192"></canvas> 
</div> 
<script src="localforage.js"></script> 
<script> 

var uiCurrentMode = 'welcome' 
var plugins = {} 
var body = document.getElementsByTagName("body")[0] 
var html = document.getElementsByTagName("html")[0] 
var config = { 
swapTopBottom: false, 
swapTopBottomL: false, 
powerSave: true, 
micWhenR: true, 
vkEnabled: true, 
} 

function loadConfig() { 
var cfg = JSON.parse(window.localStorage['config'] || '{}') 
for (var k in cfg) { 
config[k] = cfg[k] 
} 
$id('power-save').checked = config.powerSave 
$id('vk-enabled').checked = config.vkEnabled 
} 
loadConfig() 

function uiSaveConfig() { 
config.powerSave = !!($id('power-save').checked) 
config.vkEnabled = !!($id('vk-enabled').checked) 
window.localStorage['config'] = JSON.stringify(config) 
} 


function uiMenuBack() { 
uiSaveConfig() 
if (emuIsGameLoaded) { 
uiSwitchTo('player') 
} else { 
uiSwitchTo('welcome') 
} 
} 

function uiSaveBackup() { 
localforage.getItem('sav-' + gameID).then((data) => { 
var blob = new Blob([data], { type: "application/binary" }); 
var link = document.createElement("a"); 
link.href = window.URL.createObjectURL(blob); 
link.download = 'sav-' + gameID + '.dsv'; 
link.click(); 
}) 
} 

async function uiSaveRestore() { 
var file = $id('restore-file').files[0] 
if (!file) { 
return 
} 
if (file.size > 2.2 * 1024 * 1024) { 
alert('Too large!'); 
return 
} 
// Only .dsv files are supported 
if (!file.name.endsWith('.dsv')) { 
alert('Only .dsv files are supported.') 
return 
} 
var u8 = new Uint8Array(await file.arrayBuffer()) 
localforage.setItem('sav-' + gameID, u8).then(() => { 
alert('Save file loaded. The game will be restarted.') 
location.reload() 
}) 
} 


window.onerror = function (msg, url, line, col, error) { 
var extra = !col ? '' : '\ncolumn: ' + col; 
extra += !error ? '' : '\nerror: ' + error; 
alert("Error: " + msg + "\nurl: " + url + "\nline: " + line + extra); 
window.onerror = console.log 
debugger 
return true; 
}; 

function $id(id) { 
return document.getElementById(id); 
} 

var isIOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform); 
var isWebApp = navigator.standalone || false 
var isSaveSupported = true 
var isSaveNagAppeared = false 
if (isIOS) { 
//document.getElementById('romFile').files = null; 
if (!isWebApp) { 
// On iOS Safari, the indexedDB will be cleared after 7 days. 
// To prevent users from frustration, we don't allow savegame on iOS unless the we are in the PWA mode. 
isSaveSupported = false 
var divIosHint = $id('ios-hint') 
divIosHint.hidden = false 
divIosHint.style = 'position: absolute; bottom: ' + divIosHint.clientHeight + 'px;' 
} 
} 

var emuKeyState = new Array(14) 
const emuKeyNames = ["right", "left", "down", "up", "select", "start", "b", "a", "y", "x", "l", "r", "debug", "lid"] 
var vkMap = {} 
var vkState = {} 
var keyNameToKeyId = {} 
var vkStickPos 
for (var i = 0; i < emuKeyNames.length; i++) { 
keyNameToKeyId[emuKeyNames[i]] = i 
} 
var isLandscape = false 

const emuKeyboradMapping = [39, 37, 40, 38, 16, 13, 90, 88, 65, 83, 81, 87, -1, 8] 
var emuGameID = 'unknown' 
var emuIsRunning = false 
var emuIsGameLoaded = false 
var fps = 0 
var divFPS = $id('fps') 
var fileInput = $id('rom') 
var romSize = 0 

var FB = [0, 0] 
var screenCanvas = [document.getElementById('top'), document.getElementById('bottom')] 
var ctx2d = screenCanvas.map((v) => { return v.getContext('2d', { alpha: false }) }) 

var audioContext 
var audioBuffer 
var tmpAudioBuffer = new Int16Array(16384 * 2) 
var audioWorkletNode 

var frameCount = 0 
var prevCalcFPSTime = 0 
var touched = 0 
var touchX = 0 
var touchY = 0 
var prevSaveFlag = 0 
var lastTwoFrameTime = 10 
var fbSize 


function callPlugin(type, arg) { 
for (var k in plugins) { 
if (plugins[k].handler) { 
plugins[k].handler(type, arg) 
} 
} 
} 

function showMsg(msg) { 
document.getElementById('msg-text').innerText = msg 
document.getElementById('msg-layer').hidden = false 
setTimeout(function () { 
document.getElementById('msg-layer').hidden = true 
}, 1000) 
} 

function emuRunFrame() { 
processGamepadInput() 
var keyMask = 0; 
for (var i = 0; i < 14; i++) { 
if (emuKeyState[i]) { 
keyMask |= 1 << i 
} 
} 
var mic = emuKeyState[11] 
if (mic) { 
console.log('mic') 
keyMask |= 1 << 14 
} 


if (config.powerSave) { 
Module._runFrame(0, keyMask, touched, touchX, touchY) 
} 
Module._runFrame(1, keyMask, touched, touchX, touchY) 

ctx2d[0].putImageData(FB[0], 0, 0) 
ctx2d[1].putImageData(FB[1], 0, 0) 
if (audioWorkletNode) { 
try { 
var samplesRead = Module._fillAudioBuffer(4096) 
tmpAudioBuffer.set(audioBuffer.subarray(0, samplesRead * 2)) 
audioWorkletNode.port.postMessage(tmpAudioBuffer.subarray(0, samplesRead * 2)) 
} catch (error) { 
// tmpAudioBuffer may be detached if previous message is still processing 
console.log(error) 
} 
} 

frameCount += 1 
if (frameCount % 120 == 0) { 
var time = performance.now() 
fps = 120 / ((time - prevCalcFPSTime) / 1000) 
prevCalcFPSTime = time 
divFPS.innerText = 'fps:' + ('' + fps).substring(0, 5) 
} 
if (frameCount % 60 == 0) { 
checkSaveGame() 
} 
} 

function wasmReady() { 
Module._setSampleRate(47860) 
$id('loading').hidden = true 
$id('loadrom').hidden = false 
} 


function checkSaveGame() { 
var saveUpdateFlag = Module._savUpdateChangeFlag() 
if ((saveUpdateFlag == 0) && (prevSaveFlag == 1)) { 
var size = Module._savGetSize() 
if ((size > 0) && (isSaveSupported)) { 
var ptr = Module._savGetPointer(0) 
var tmpSaveBuf = new Uint8Array(size) 
tmpSaveBuf.set(Module.HEAPU8.subarray(ptr, ptr + size)) 
localforage.setItem('sav-' + gameID, tmpSaveBuf) 
showMsg('Auto saving...') 
} 
} 
prevSaveFlag = saveUpdateFlag 
} 

async function tryLoadROM(file) { 
if (!file) { 
return 
} 
if (file.size < 1024) { 
return 
} 
var header = new Uint8Array(await (file.slice(0, 1024)).arrayBuffer()) 
gameID = '' 
for (var i = 0; i < 0x10; i++) { 
gameID += (header[i] == 0) ? ' ' : String.fromCharCode(header[i]) 
} 
if (gameID[0xC] == '#') { 
// a homebrew! 
gameID = file.name 
} 
console.log('gameID', gameID) 
romSize = file.size 
var romBufPtr = Module._prepareRomBuffer(romSize) 
console.log(romSize, romBufPtr) 
Module.HEAPU8.set(new Uint8Array(await file.arrayBuffer()), romBufPtr); 
var saveData = await localforage.getItem('sav-' + gameID) 
if (saveData) { 
Module.HEAPU8.set(saveData, Module._savGetPointer(saveData.length)) 
} 
Module._savUpdateChangeFlag() 
var ret = Module._loadROM(romSize); 
if (ret != 1) { 
alert('LoadROM failed.') 
return; 
} 


ptrFrontBuffer = Module._getSymbol(5) 
var fb = Module._getSymbol(4) 
for (var i = 0; i < 2; i++) { 
FB[i] = new ImageData(new Uint8ClampedArray(Module.HEAPU8.buffer).subarray(fb + 256 * 192 * 4 * i, fb + 256 * 192 * 4 * (i + 1)), 256, 192) 
} 
var ptrAudio = Module._getSymbol(6) 
audioBuffer = new Int16Array(Module.HEAPU8.buffer).subarray(ptrAudio / 2, ptrAudio / 2 + 16384 * 2) 
console.log('Start!!!') 
emuIsGameLoaded = true 
emuIsRunning = true 
uiSwitchTo('player') 
callPlugin('loaded', gameID) 
} 

function initVK() { 
var vks = document.getElementsByClassName('vk') 
for (var i = 0; i < vks.length; i++) { 
var vk = vks[i] 
var k = vks[i].getAttribute('data-k') 
if (k) { 
vkMap[k] = vk 
vkState[k] = [0, 0] 
} 
} 
} 
initVK() 

function makeVKStyle(top, left, w, h, fontSize) { 
return 'top:' + top + 'px;left:' + left + 'px;width:' + w + 'px;height:' + h + 'px;' + 'font-size:' + fontSize + 'px;line-height:' + h + 'px;' 
} 


function uiAdjustVKLayout() { 
var baseSize = window.innerWidth * 0.14 
var fontSize = baseSize * 0.7 
var offTop = Math.min(fbSize[0][1] + fbSize[1][1], window.innerHeight - Math.ceil(baseSize * 3.62)) 
var offLeft = 0 
var abxyWidth = baseSize * 3 
var abxyHeight = baseSize * 3 
var vkw = baseSize 
var vkh = baseSize 

vkw = baseSize * 1.5 
vkh = baseSize * 0.6 
fontSize = baseSize * 0.5 
vkMap['l'].style = makeVKStyle(offTop, 0, vkw, vkh, fontSize) 
vkMap['r'].style = makeVKStyle(offTop, window.innerWidth - vkw, vkw, vkh, fontSize) 
$id('vk-menu').style = makeVKStyle(offTop, window.innerWidth / 2 - vkw / 2, vkw, vkh, fontSize) 


offTop += baseSize * 0.62 
vkw = baseSize 
vkh = baseSize 
offLeft = window.innerWidth - abxyWidth 
vkMap['a'].style = makeVKStyle(offTop + abxyHeight / 2 - vkh / 2, offLeft + abxyWidth - vkw, vkw, vkh, fontSize) 
vkMap['b'].style = makeVKStyle(offTop + abxyHeight - vkh, offLeft + abxyWidth / 2 - vkw / 2, vkw, vkh, fontSize) 
vkMap['x'].style = makeVKStyle(offTop, offLeft + abxyWidth / 2 - vkw / 2, vkw, vkh, fontSize) 
vkMap['y'].style = makeVKStyle(offTop + abxyHeight / 2 - vkh / 2, offLeft, vkw, vkh, fontSize) 

vkw = baseSize * 1.0 
vkh = baseSize * 1.0 
offLeft = 0 
$id('vk-stick').style = makeVKStyle(offTop + abxyHeight / 2 - vkh / 2, offLeft + abxyHeight / 2 - vkw / 2, vkw, vkh, fontSize) 
vkStickPos = [offTop + abxyHeight / 2, offLeft + abxyHeight / 2, vkw, vkh, fontSize] 

vkw = baseSize * 0.4 
vkh = baseSize * 0.4 
fontSize = baseSize * 0.4 
vkMap['select'].style = makeVKStyle(offTop + abxyHeight - vkh, window.innerWidth / 2 - vkw * 1.5, vkw, vkh, fontSize) 
vkMap['start'].style = makeVKStyle(offTop + abxyHeight - vkh, window.innerWidth / 2 + vkw * 0.5, vkw, vkh, fontSize) 
} 

function uiUpdateLayout() { 
isLandscape = window.innerWidth > window.innerHeight 
var maxWidth = window.innerWidth 
var maxHeight = window.innerHeight / 2 
var w = maxWidth 
var h = w / 256 * 192 
if (h > maxHeight) { 
h = maxHeight 
w = h / 192 * 256 
} 
var left = 0 
left += (window.innerWidth - w) / 2; 
var top = 0 

fbSize = [[w, h], [w, h]] 
for (var i = 0; i < 2; i++) { 
screenCanvas[i].style = 'left:' + left + 'px;top:' + top + "px;width:" + w + "px;height:" + h + "px;" 
top += h 
} 
uiAdjustVKLayout() 
} 


function uiSwitchTo(mode) { 
if (mode == uiCurrentMode) { 
return 
} 
uiCurrentMode = mode 
$id('welcome').hidden = true 
$id('vk-layer').hidden = true 
$id('menu').hidden = true 
$id('player').hidden = true 
body.style = '' 
html.style = '' 
emuIsRunning = false 

if (mode == 'player') { 
body.style = 'touch-action: none;' 
html.style = 'position: fixed;overflow:hidden;touch-action: none;' 
for (var i = 0; i < 14; i++) { 
emuKeyState[i] = false 
} 
if (config.vkEnabled) { 
$id('vk-layer').hidden = false 
} 
uiUpdateLayout() 
if (emuIsGameLoaded) { 
emuIsRunning = true 
} 
$id('player').hidden = false 
} 
if (mode == 'menu') { 
$id('player').hidden = false 
$id('menu').hidden = false 
$id('menu-savegame').hidden = emuIsGameLoaded ? false : true 
} 
if (mode == 'welcome') { 
$id('welcome').hidden = false 
} 

} 




fileInput.onchange = async () => { 
tryInitSound() 
var file = fileInput.files[0] 
if (!file) { 
return 
} 
if (file.name.endsWith('.json')) { 
var obj = JSON.parse(await file.text()) 
var pluginName = obj.name || 'unknown' 
plugins[pluginName] = obj 
if (obj.js) { 
plugins[pluginName].handler = eval(obj.js)(obj) 
} 
alert('plugin loaded!') 
return 
} 
await tryLoadROM(file) 
} 


// must be called in user gesture 
function tryInitSound() { 
try { 
if (audioContext) { 
if (audioContext.state != 'running') { 
audioContext.resume() 
} 
return; 
} 
audioContext = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 0.0001, sampleRate: 48000 }); 
if (!audioContext.audioWorklet) { 
alert('AudioWorklet is not supported in your browser...') 
} else { 
audioContext.audioWorklet.addModule("audio-worklet.js").then(() => { 
audioWorkletNode = new AudioWorkletNode(audioContext, "my-worklet", { outputChannelCount: [2] }) 
audioWorkletNode.connect(audioContext.destination) 
}) 
} 

audioContext.resume() 
} catch (e) { 
console.log(e) 
//alert('Cannnot init sound ') 
} 
} 

var prevRunFrameTime = performance.now() 
function emuLoop() { 
window.requestAnimationFrame(emuLoop) 

if (emuIsRunning) { 
if (config.powerSave) { 
if (performance.now() - prevRunFrameTime < 32) { 
return 
} 
} 
prevRunFrameTime = performance.now() 
emuRunFrame() 
} 
} 
emuLoop() 

var stickTouchID = null 
var tpadTouchID = null 

function isPointInRect(x, y, r) { 
if ((x >= r.x) && (x < r.x + r.width)) { 
if ((y >= r.y) && (y < r.y + r.height)) { 
return true 
} 
} 
return false 
} 

function clamp01(a) { 
if (a < 0) { 
return 0 
} 
if (a > 1) { 
return 1 
} 
return a 
} 

function handleTouch(event) { 
tryInitSound() 
if (!emuIsRunning) { 
return 
} 
event.preventDefault(); 
event.stopPropagation(); 

var isDown = false 
var x = 0 
var y = 0 

var needUpdateStick = false 
var stickY = vkStickPos[0] 
var stickX = vkStickPos[1] 
var stickW = vkStickPos[2] 
var stickH = vkStickPos[3] 

var stickPressed = false 
var stickDeadZone = stickW * 0.4 

var nextStickTouchID = null 
var nextTpadTouchID = null 

var tsRect = screenCanvas[1].getBoundingClientRect() 

for (var i = 0; i < emuKeyState.length; i++) { 
emuKeyState[i] = false 
} 
for (var k in vkState) { 
vkState[k][1] = 0 
} 

for (var i = 0; i < event.touches.length; i++) { 
var t = event.touches[i]; 
var tid = t.identifier 
var dom = document.elementFromPoint(t.clientX, t.clientY) 
var k = dom ? dom.getAttribute('data-k') : null 

if ((tid === stickTouchID) || ((dom == vkMap['stick']) && (tid != tpadTouchID))) { 
stickPressed = true 

vkState['stick'][1] = 1 
var sx = t.clientX 
var sy = t.clientY 
if (sx < stickX - stickDeadZone) { 
emuKeyState[1] = true 
} 
if (sx > stickX + stickDeadZone) { 
emuKeyState[0] = true 
} 
if (sy < stickY - stickDeadZone) { 
emuKeyState[3] = true 
} 
if (sy > stickY + stickDeadZone) { 
emuKeyState[2] = true 
} 
sx = Math.max(stickX - stickW / 2, sx) 
sx = Math.min(stickX + stickW / 2, sx) 
sy = Math.max(stickY - stickH / 2, sy) 
sy = Math.min(stickY + stickH / 2, sy) 
stickX = sx 
stickY = sy 
needUpdateStick = true 
nextStickTouchID = tid 
continue 
} 
if ((tid === tpadTouchID) || (isPointInRect(t.clientX, t.clientY, tsRect) && (!k))) { 
isDown = true 
x = clamp01((t.clientX - tsRect.x) / tsRect.width) * 256 
y = clamp01((t.clientY - tsRect.y) / tsRect.height) * 192 
nextTpadTouchID = tid 
continue 
} 
if (k) { 

vkState[k][1] = 1 
continue 
} 
} 

touched = isDown ? 1 : 0; 
touchX = x 
touchY = y 

for (var k in vkState) { 
if (vkState[k][0] != vkState[k][1]) { 
var dom = vkMap[k] 
vkState[k][0] = vkState[k][1] 
if (vkState[k][1]) { 
dom.classList.add('vk-touched') 
if (k == 'menu') { 
uiSwitchTo('menu') 
} 
} else { 
dom.classList.remove('vk-touched') 
if (k == "stick") { 
needUpdateStick = true 
} 
} 

} 
} 

for (var i = 0; i < emuKeyState.length; i++) { 
var k = emuKeyNames[i] 
if (vkState[k]) { 
if (vkState[k][1]) { 
emuKeyState[i] = true 
} 
} 
} 

if (needUpdateStick) { 
vkMap['stick'].style = makeVKStyle(stickY - stickW / 2, stickX - stickW / 2, stickW, stickH, vkStickPos[4]) 
} 

stickTouchID = nextStickTouchID 
tpadTouchID = nextTpadTouchID 
} 
['touchstart', 'touchmove', 'touchend', 'touchcancel', 'touchenter', 'touchleave'].forEach((val) => { 
window.addEventListener(val, handleTouch) 
}) 




window.onmousedown = window.onmouseup = window.onmousemove = (e) => { 
if (!emuIsRunning) { 
return 
} 
if (e.type == 'mousedown') { 
tryInitSound() 
} 

var r = screenCanvas[1].getBoundingClientRect() 

e.preventDefault() 
e.stopPropagation() 

var isDown = (e.buttons != 0) && (isPointInRect(e.clientX, e.clientY, r)) 
var x = (e.clientX - r.x) / r.width * 256 
var y = (e.clientY - r.y) / r.height * 192 

touched = isDown ? 1 : 0; 
touchX = x 
touchY = y 
} 

window.onresize = window.onorientationchange = () => { 
uiUpdateLayout() 
} 
function convertKeyCode(keyCode) { 
for (var i = 0; i < 14; i++) { 
if (keyCode == emuKeyboradMapping[i]) { 
return i 
} 
} 
return -1 
} 
window.onkeydown = window.onkeyup = (e) => { 
if (!emuIsRunning) { 
return 
} 
e.preventDefault() 
var isDown = (e.type === "keydown") 
var k = convertKeyCode(e.keyCode) 
if (k >= 0) { 
emuKeyState[k] = isDown 
} 
if (e.keyCode == 27) { 
uiSwitchTo('menu') 
} 
} 

var currentConnectedGamepad = -1 
var gamePadKeyMap = { 
a: 1, 
b: 0, 
x: 3, 
y: 2, 
l: 4, 
r: 5, 
'select': 9, 
'start': 16, 
'up': 12, 
'down': 13, 
'left': 14, 
'right': 15 
} 

window.addEventListener("gamepadconnected", function (e) { 
console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.", 
e.gamepad.index, e.gamepad.id, 
e.gamepad.buttons.length, e.gamepad.axes.length); 
showMsg('Gamepad connected.') 
currentConnectedGamepad = e.gamepad.index 

}); 

function processGamepadInput() { 
if (currentConnectedGamepad < 0) { 
return 
} 
var gamepad = navigator.getGamepads()[currentConnectedGamepad] 
if (!gamepad) { 
showMsg('Gamepad disconnected.') 
currentConnectedGamepad = -1 
return 
} 
for (var i = 0; i < emuKeyState.length; i++) { 
emuKeyState[i] = false 
} 
for (var k in gamePadKeyMap) { 
if (gamepad.buttons[gamePadKeyMap[k]].pressed) { 
emuKeyState[keyNameToKeyId[k]] = true 
} 
} 
if (gamepad.axes[0] < -0.5) { 
emuKeyState[keyNameToKeyId['left']] = true 
} 
if (gamepad.axes[0] > 0.5) { 
emuKeyState[keyNameToKeyId['right']] = true 
} 
if (gamepad.axes[1] < -0.5) { 
emuKeyState[keyNameToKeyId['up']] = true 
} 
if (gamepad.axes[1] > 0.5) { 
emuKeyState[keyNameToKeyId['down']] = true 
} 
} 

function whatsNew() { 
alert(` 
1. Added setting option to hide the virtual keyboard. 
`) 
} 
</script> 
<script src="build/nds.js"></script> 
<script src="sw-loader.js"></script> 
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').then(registration => {
      console.log('ServiceWorker registration successful.');
    }).catch(err => {
      console.log('ServiceWorker registration failed.');
    });
  }
</script>
</body> 

</html>
